## 스프링 입문을 위한 자바 객체 지향의 원리와 이해

#### 저자 : 김종민

### 자바 프로그램

* * *

- JDK : 자바 개발 도구 (소프트웨어 개발 도구)
- JRE : 자바 실행 환경 (운영체제)
    - JVM이 동작할 수 있게 부팅하고 관리한다.
- JVM : 자바 가상 기계 (가상 컴퓨터)
- main() 메서드가 종료되면, 데이터 저장 메모리 소멸 & JVM 기동 중지 & JRE가 사용했던 시스템 자원을 운영체제에 반납한다.
- 자바는 위와 같은 구조를 가지며 다른 플랫폼에서 프로그램을 작성하더라도, 모든 플랫폼에서 실행이 가능하도록 되어있다.
    - Write Once, Run Anywhere
- 절차적/구조적 프로그래밍
    - 절차대로 진행되는
    - 함수를 사용하여 중복된 부분을 모아 관리하고, 논리 단위를 나누는
- 객체 지향 프로그래밍
    - 함수 → 메서드
    - 함수는 클래스나 객체 지향과 아무 관계가 없지만, 메서드는 항상 클래스 안에 존재해야 한다.
- 자바의 데이터 저장 메모리 구조
    - 스태틱 영역 : 클래스 변수
    - 스택 영역 : 지역 변수
    - 힙 영역 : 객체 변수

### 자바와 객체 지향

* * *

- 기존의 구조적 프로그래밍 언어에서 가장 중요한 것은 ‘함수'였다.
    - 분할, 블록화
- 사람이 더 편할 수 있는, 현실 세계를 인지하는 방식으로 프로그램을 만들자.
- 각 사물(Object)은 고유하며, 속성을 가지고 행위를 한다.
- 사물은 분류(Class)가 가능하다.
- 객체 지향은 직관적이고 이해하기 쉽다.
- 클래스 = 개념/분류/집합, 객체 = 실체


- 객체 지향의 4대 특성
    - 캡슐화
        - 접근 제어자를 통해 노출 시킬 부분과 감출 부분을 나눈다.

    - 상속
        - 재사용과 확장
        - 상위 클래스의 개념을 하위 클래스에서 상속하고, 거기에 필요한 기능을 더해 확장하여 사용하는 것이다.
        - 상위 클래스로 올라갈수록 추상화, 일반화하위 클래스로 내려갈수록 구체화, 특수화
        - 하위클래스는 상위 클래스이다.
            - 클래스명은 클래스 답게, 객체 참조변수명은 객체답게 지어야한다.
        - 다중 상속
            - 여러 상위 개념을 가지고 있는 경우, 행위/속성이 중복될 수 있고하위에서는 어떤것을 따라야 할지 모르게된다. (다이아몬드 문제)
        - 인터페이스
            - ‘무엇을 할 수 있다’는 기능을 구현하게 한다.

    - 추상화
        - 추상 : 여러 사물이나 개념에서 관심 영역에 있는 공통적인 특성이나 속성을 추출하여 파악하는 작용
        - 모델링
        - 객체의 공통적인 특성을 뽑아 클래스로 만드는 것
    - 다형성
        - 상위 클래스의 기능을 재정의(오버라이딩) 할 수 있고, 호츨시에는 하위 클래스에서 재정의 한 기능이 호출된다.


- 객체 지향의 확장
    - 추상 클래스
        - 인스턴스화 될 수 없는 클래스
    - 추상 메서드
        - 상속한 클래스가 반드시 오버라이딩 해야 하는 메서드
    - static 블록
        - 클래스가 코드에서 맨 처음 사용될 때, 스태틱영역에 로딩되며이 때 단 한번 해당 클래스의 static 블록이 실행된다.
    - final
        - 클래스 : 상속이 불가능하다.
        - 변수 : 변경이 불가능하다. = 상수
        - 메서드 : 오버라이딩이 불가능하다.

### SOLID : 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙

* * *

- 좋은 소프트웨어 설계를 위해서는 응집도를 높이고, 결합도는 낮추어야 한다.
    - 응집도 : 하나의 클래스 안에 존재하는 구성 요소들의 기능적 관련성
    - 결합도 : 클래스 간의 상호 의존 정도


1. SRP(Single Responsibility Principle)
    - 단일 책임 원칙
    - 하나의 속성, 클래스, 메서드가 하나의 책임만을 가지는 것을 말한다.
    - 추상화를 통해 공통 속성을 가진 클래스를 선별할 때, 단일 책임 원칙을 고려해야 한다.

2. OCP(Open Closed Principle)
    - 개방 폐쇄 원칙
    - 자신은 확장은 가능해야 하지만 주변의 코드는 변경하면 안된다.

3. LSP(Liskov Substitution Principle)
    - 리스코프 치환 원칙
    - 하위(서브)타입은 언제나 자신의 상위(기반)타입으로 교체될 수 있어야 한다.
    - 상속과 인터페이스 구현은 계층도나 조직도가 되는 것이 아니라분류, 특성이 되어야 한다.

4. ISP(Interface Segregation Principle)
    - 인터페이스 분리 원칙
    - 자신이 사용하지 않는 특성(메서드)에 의존 관계를 맺으면 안된다.
    - 클래스가 하나의 책임만을 갖도록(단일 책임 원칙) or 인터페이스를 통해 역할을 분리시키는(인터페이스 분리 원칙) 방식으로 결합도를 낮출 수 있다.
        - 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책일 수 있다.

5. DIP(Dependency Inversion Principle)
    - 의존 역전 원칙
    - 자신보다 변하기 쉬운것에 의존하면 안된다.
    - 구체적인 것(객체)에 의존하는 것이 아니라 이 객체를 추상화 한 것에 의존하여 변경 되더라도 유연하게 확장할 수 있게 해야한다.
    - 확장은 가능해야 하지만 변경되면 안되는 OCP와도 연관되어 있다.


- SoC (Separation Of Concerns)
    - 관심사의 분리
    - 하나의 속성, 하나의 메서드, 클래스, 모듈, 패키지에는 하나의 관심사만 들어있어야 한다.
    - SRP, OCP, ISP

### 스프링이 사랑한 디자인 패턴

* * *

- 표준 설계 패턴
- 수많은 비즈니스 요구 사항을 프로그래밍으로 처리하면서 만들어진 다양한 해결책 중 많은 사람들이 인정한 좋은 방법들을 정리한 것
- 디자인 패턴은 상속, 인터페이스, 합성(객체를 속성으로 사용)을 이용한다.


1. 어댑터(변환기) 패턴
    - 객체를 속성으로 만들어서 참조하는 디자인 패턴이다.
    - 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출한다.

2. 프록시(대리자) 패턴
    - 실제 접근하는 객체의 중간에 프록시 객체를 추가하여 접근을 제어하거나 대리자로서 역할을 수행한다.

3. 데코레이터(도장/도배업자) 패턴
    - 원본에 장식을 더한다. (반환값에 장식을 추가한다.)

4. 싱글턴 패턴
    - 인스턴스를 하나만 만들어 사용한다.
    - 하나의 인스턴스만을 참조하는 static 변수를 정의한다.
    - 인스턴스를 생성할 수 없도록 생성자의 접근제어자를 private 으로 설정한다.
    - 하나의 인스턴스를 반환하는 static 메서드(getInstance())를 정의한다.
    - 읽기 전용 속성 외에 변경 가능한 속성은 사용하지 않는 것이 좋다.

5. 템플릿 메서드 패턴
    - 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩 한 메서드를 호출한다.

6. 팩터리 메서드 패턴
    - 상위 클래스의 메서드에서 하위 클래스가 오버라이딩한 메서드에서 생성된 객체를 반환한다.

7. 전략 패턴
    - 전략 메서드를 가진 전략 객체
    - 전략 객체를 사용하는 컨텍스트(전략 객체의 사용자/소비자)
    - 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(제3자, 전략 객체의 공급자)
    - 클라이언트가 전략(객체)를 생성해 실행할 컨텍스트에게 주입하는 패턴이다.
    - 템플릿 메서드 패턴에서는 상속을 받아 오버라이딩 한 함수를 호출하지만, 전략 패턴에서는 생성한 객체를 주입하여 처리한다.

8. 템플릿 콜백 패턴
    - 전략패턴과 동일한데, 전략을 익명 내부 클래스로 정의해서 사용한다.

9. 프론트 컨트롤러 패턴
    - 가장 앞에서 모든 요청을 처리하는 컨트롤러가 하나 존재하고, 이 프론트 컨트롤러가 적절한 컨트롤러나 핸들러를 호출하여 요청을 처리한다.- 요청의 중앙 집중화, 공통 전후처리, 확장성 등의 장점이 있다.

10. MVC 패턴
    - 모델: 데이터처리
    - 뷰: 시각적 표현
    - 컨트롤러: 사용자의 요청을 처리, 모델과 뷰를 변경

### 스프링 삼각형

* * *

- POJO(Plain Old Java Object)를 기반으로한 스프링의 3대 프로그래밍 모델


1. IoC / DI
   - 제어의 역전 / 의존성 주입
   - 의존성
       - 전체가 부분에 의존한다.
       - new 로 표현된다.
   - 의존성 주입
       - 내부에서 객체를 생성하는 것이 아니라 주입받아 사용한다.
       - 직접 내부에서 사용하는 객체를 생성하는 것은 유연성이 떨어진다.
       - 객체를 생성시에 주입하면 사용시마다 변경이 가능하다.
       - 유연성, 확장성이 높아진다.
       - 생성자를 통해 주입하거나 속성(get/set)을 통해 주입한다.

2. AOP
   - Aspect-Oriented Programming
   - 관점 지향 프로그래밍
   - 로직(code)을 주입한다.
   - 로직을 주입할 수 있는 위치
       - 메서드 전 구역   
       - 메서드 시작 직후
       - 메서드 종료 직전
       - 메서드 정상 종료 후
       - 메서드 예외 발생 종료 후
   - 여러 모듈에서 공통으로 사용하는 로직(횡단 관심사)을 분리하여 주입한다.
   - 횡단 관심사를 분리하면 자연스럽게 각 클래스에는 핵심 관심사(클래스마다 다르게 진행되는 부분)만 남아 자동으로 SRP(단일 책임 원칙)가 적용된다.
3. PSA
   - Portable Service Abstraction
   - 일관성있는 서비스 추상화
   - 어댑터 패턴을 사용해 같은 일을 하는 다수의 기술을 곹옹의 인터페이스로 제어할 수 있게 한다.