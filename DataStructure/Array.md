## Array (배열)


### 배열이란

---

<img src="array_img/img.png.png" width="50%" alt=""/>

- 데이터를 순차적으로 저장하며, 모든 데이터가 한 공간에 인접하여 존재하는 자료구조이다.
- 인덱스(`index`)와 요소(`element`)로 구성된다.
    - 인덱스: 위 그림에서 0, 1, 2 와 같이 데이터의 순서를 나타내는 번호
    - 요소: 위 그림에서 A, E, B 와 같이 저장되는 값
- 실제 메모리 상에서 연속적이고 정해진 크기의 공간을 할당받는다.
- 배열의 데이터는 비어있는 부분 없이 인접하여 존재한다.


### 장점

---

- 데이터에 **빠르게 접근**할 수 있다.
    - 메모리에서 배열이 위치한 공간을 찾으면 그 안에서 데이터는 인덱스로 관리된다.
    - 인덱스를 알고 있다면, 이를 통해 빠르게 데이터에 접근할 수 있다.

### 단점

---

- 처음 정해진 **크기를 변경할 수 없다**.
    - 배열은 생성 시에 크기가 정해지기 때문에, 데이터를 정해진 크기보다 더 추가하고 싶어도 불가능하고, 적게 저장하더라도 이미 메모리를 할당받았기 때문에 낭비되는 공간이 생긴다.



### 동작

---

#### 1. 읽기 (Read)
- 시간 복잡도: `O(1)`
- 데이터를 인덱스를 통해 접근할 수 있어 빠른 접근이 가능하다.
- 많은 데이터를 읽기에 적합하다.

> **시간 복잡도란,**
데이터를 읽거나 검색하거나 삽입/삭제하는 등의 **동작이 완료되기까지 얼만큼의 연산이 필요한지를 데이터의 개수와 비교하여 계산**한 것이다.
>
>시간 복잡도는 보통 **빅오표기법**과 같은 수학적 표기법을 통해 나타내며, 이를 통해 어떤 상황에서 어떤 자료구조/알고리즘이 더 좋을지 판단해 볼 수 있다.
>
>시간 복잡도는 데이터의 위치, 상황에 따라서도 달라질 수 있는데, 빅오표기법은 **가장 최악의 상황(연산이 가장 많이 필요한 상황)** 을 계산하여 표현하는 것이다. 가장 최악의 상황으로 계산하는 이유는, 동작의 모든 경우의 수를 포함하기 위함이다.
>
>빅오표기법은 데이터의 개수가 `n`개일 때, 개수와 관계없이 일정 횟수의 연산을 수행해야 한다면 `O(1)`, 데이터의 개수만큼 연산을 수행해야 한다면 `O(n)` 으로 표현할 수 있다.
>이때 `O(1)`이 `O(n)`보다 시간 복잡도가 낮다고 표현할 수 있으며,
>**시간 복잡도가 낮은 경우에 더 빠른 동작이 가능**하다고 볼 수 있다.

#### 2. 검색 (Search)
- 검색하는 방식(알고리즘)에 따라 시간 복잡도는 달라질 수 있다.
- Linear Search (선형 검색)
    - 시간 복잡도: `O(n)`
    - 배열의 첫 번째 데이터부터, 찾는 데이터와 비교하면서 검색하는 방법이다.
    - 찾을 때까지 처음부터 끝까지 비교하기 때문에 찾는 데이터가 배열의 끝에 있을수록(혹은 없는 경우) 비교 연산이 많이 수행된다.
- Binary Search (이진 검색)

  <img src="array_img/img_1.png" width="50%" alt=""/>

    - 시간 복잡도: `O(logN)`
    - 위 그림과 같이 데이터가 정렬된 배열에서만 사용 가능하다.
    - 배열을 반으로 나누어서 가장 가운데 데이터와 비교하면서 찾는 방법이다.
      (오름차순으로 정렬된 배열에서 가운데 데이터보다 찾는 데이터가 작은 경우 왼쪽 범위를, 크다면 오른쪽 범위를 계속 비교하면서 찾아나간다.)
    - 선형 검색처럼 처음부터 모든 데이터와 비교하는 것이 아니라 찾는 범위를 반으로 나눠 좁혀 나가기 때문에 선형 검색보다 빠르다.
    - 데이터가 `n`개일 때 최대 `2/n`번의 비교 연산이 필요하기 때문에
      시간 복잡도는 `O(logN)`이 된다.
    - 정렬된 배열의 삽입, 삭제는 그렇지 않은 배열보다 느리므로(삽입/삭제 시에 정렬을 진행해야 하기 때문) 빠른 검색이 필요한 경우에 이진 검색을 고려해 볼 수 있다.


#### 3. 삽입 (Insert)
- 시간 복잡도: `O(N)`
- 데이터를 어디에(위치) 추가하는지에 따라 연산의 수가 달라질 수 있다.
    - 끝: 가장 끝 자리에 바로 추가한다.
    - 중간: 추가될 위치의 데이터부터 모두 한 칸씩 뒤로 이동하고 새로운 데이터를 추가한다.
    - 앞: 제일 앞의 데이터부터 모두 한 칸씩 뒤로 이동하고 새로운 데이터를 추가한다. (최악의 상황)
- 제일 앞자리에 데이터를 추가하여 이동 연산이 많이 수행되는 상황으로 시간 복잡도를 계산한다.


#### 4. 삭제 (Delete)
- 시간 복잡도: `O(N)`
- 어디에(위치) 있는 데이터를 삭제하는지에 따라 연산의 수가 달라질 수 있다.
    - 끝: 가장 끝 데이터를 바로 삭제한다.
    - 중간: 데이터를 삭제하고, 삭제한 뒤의 데이터를 모두 한 칸씩 앞으로 이동한다.
    - 앞: 가장 앞의 데이터를 삭제하고 모든 데이터를 한 칸씩 앞으로 이동한다. (최악의 상황)
- 제일 앞자리의 데이터를 삭제하여 이동 연산이 많이 수행되는 상황으로 시간 복잡도를 계산한다.