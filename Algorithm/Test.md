## 코딩테스트 준비

### 구간합

- 배열의 특정 구간의 합을 구하는 것
    - 합배열을 먼저 생성하기
    - 합 배열 공식: S\[i\] = S\[i-1\] + A\[i\] (S는 합배열, A는 원본 배열), S\[0\] = A\[0\]
- i부터 j까지의 구간합: S\[j\] - S\[i-1\]

### 연산 시간 계산

- 1억번 연산 = 1초 예상

### 많은 문자열을 입력받아 처리하는 경우

- Scanner 보다 BufferedReader로 처리하는 것이 빠르다.
    ```
    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
    ```

- 한줄에 문자가 많은 경우 하나씩 처리하는 것보다 StringTokenizer를 통해 끊어서 가져오는 것이 더 좋다.

    ```
    StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
    ```

### 스택 → DFS

- top: 가장 위의 데이터
- push: 삽입
- pop: 꺼내고(삭제) 확인
- peek: 확인만
    ```
    Stack<Integer> stack = new Stack<>();
    ```

  

### 큐 → BFS

- rear: 가장 끝 데이터
- front: 가장 앞 데이터
- add: rear에 삽입
- poll: front데이터를 꺼내고(삭제) 확인
- peek: front데이터를 확인만
    ```
    Queue<Integer> queue = new LinkedList<>();
    ```

## 정렬

### 버블정렬

- 데이터를 인접 요소들끼리 비교하고 swap을 통해 정렬
- 시간복잡도 O(n2): N개를 정렬하는 연산을 N번 반복하기 때문에
- 특정 루프에서 swap이 발생하지 않으면 프로세스를 종료시키기

### 선택정렬

- 최소나 최대를 찾아가면서 정렬하는 방법
- 시간복잡도 O(n2)

### 삽입정렬

- 정렬된 데이터 범위에 정렬되지 않은 데이터를 삽입하며 정렬하는 방법
- 시간복잡도 O(n2) - 이진탐색을 통해 검색의 시간복잡도를 O(logN) 으로 줄일 수 있지만, shift연산으로 인해 시간이 소요됨

### 퀵정렬

- 기준값(pivot)을 설정하여 해당 값보다 작은 데이터와 큰 데이터로 분류하는것을 반복하며 정렬하는 방법
- 평균 O(nlogn), 최악 O(n2): pivot에 따라 시간복잡도에 영향이 있음
- 피봇을 기준으로 start, end 포인트를 정해 swap 하면서 정렬을 진행

### 병합정렬(merge sort)

- 분할 정복 방식을 사용해 데이터를 분할하고, 분할한 집합을 정렬하며 합치는 방법
    - 분할정복방식
        - 나눌 수 없는 부분까지로 우선 나누기
        - 2개씩 그룹으로 묶어 정렬
            - 각각 그룹은 정렬 되어있음
        - 최종 하나의 그룹이 될때까지 반복
    - 그룹을 합치는 정렬은 투포인트 정렬 방식으로
        - 그룹의 앞의 값들부터 서로 비교하면서 정렬
        - 

- 시간복잡도: O(nlogn)
    - 한번 정렬시 N번의 데이터 접근이 필요하고
    - 정렬을 logN의 횟수만큼 진행
- 안정적, 시간복잡도도 좋음
- 이론을 이해하고 문제 푸는 종류가 많이 나옴!!

### 기수정렬

- 10개의 큐를 이용해서 (0-9) 자릿수를 비교하면서 정렬하는 방법
- 시간복잡도: O(KN)- K는 자릿수

### DFS

- 깊이 우선 탐색
- 그래프 완전 탐색 - 한쪽 분기를 다 탐색한 후에 다른 분기를 탐색
- 재귀함수로 구현, 스택 자료구조 사용
    - 스택 오버플로우에 유의해야 함 - 계속해서 함수를 호출하면 스택에 너무 많은 양이 쌓이게 됨
    - 
- 시간복잡도: O(V + E) - V:노드의 수, E:엣지의 수
- 규칙
    - 한번 방문한 노드를 다시 방문하면 안됨 - 노드 방문 여부를 체크할 배열이 필요
    - 자료구조: 인접리스트

        - 한방향이 아닌 경우에는 양쪽 모두 연결해야 함
        - 연결 요소의 개수 = DFS의 횟수

    - 스택에 노드를 삽입할 때 방문배열을 체크하여 방문되지 않은 노드만 삽입하고,스택에 노드를 뺄 때 인접 노드를 방문 배열과 비교하여 체크한 후 삽입한다.

### BFS

- 너비 우선 탐색
- 그래프 완전 탐색 - 시작 노드를 기준으로 가까운 노드부터 탐색
    - 최단 경로를 보장
- 큐 자료구조를 이용해 구현

- 시간복잡도: O(V + E) - V:노드의 수, E:엣지의 수
- 규칙
    - 한번 방문한 노드를 다시 방문하면 안됨 - 노드 방문 여부를 체크할 배열이 필요
    - 자료구조: 인접리스트
- 미로 탐색하기
    - 상하좌우를 탐색하기 위한 dx,dy 배열을 생성  
dx = {1,0,-1,0}  
dy = {0,1,0,-1}
    - 이차원 배열에 담고
    - visited 배열로 방문 요소 체크하고
    - 상하좌우로 이동하면서 조건에 맞으면 현재 위치의 값에 +1 해주기 → 이렇게 하면 depth는 자연스럽게 그 요소의 값이 됨

  

### 이진탐색

- 데이터가 정렬되어 있는 상태에서 원하는 값을 탐색
- 데이터의 크기를 절반씩 줄이면서 찾아나가는 형태

### 그리디 알고리즘

- 현재 선택지 중에서 최선의 선택을 하다보면 전체의 최선의 선택지를 고르게 된다라고 가정
- 최적의 해를 보장하진 않는다.
- 진행
    - 해 선택
    - 해 확인 - 전체의 제약조건을 위반하지 않는지 검사
    - 해 집합 검사 - 해결할 수 있는지 확인 후 미해결시 1번을 반복
- ex. 최소 동전의 수
    - 최대한 큰 금액의 동전으로 구성하기
    - 뒤의 동전 가격 Ai가 앞의 동전 가격 Ai-1의 배수가 된다는 조건이 있어야 반례가 생기지 않음

### 소수 구하기

-  소수: 1과 자신 외의 약수가 존재하지 않는 수
- 에라토스테네스의 체
    - 주어진 범위까지의 배열을 생성, 2부터 시작해서 배수를 지워가기
    - 삭제되지 않은 수를 출력
- 시간복잡도 = O(Nlog(logN)) : 뒤를 탐색할수록 범위가 줄기 때문
    - N의 제곱근 까지만 검색하기
    ```java
    for(i = 2; i < Math.sqrt(N); i++) {
        for(j = i+i; j <= N; j = j+i) {
        }
    }
    ```

### 오일러 피

- 오일러 피 함수 P\[N\]의 정의는 1~N의 범위에서 N과 서로소인 자연수의 개수
- 서로소: 공약수(공통약수)가 1이외에 없는 것
- 진행
    - 오일러 피의 범위만큼 배열을 초기화
    - 2부터 시작해서 배수마다 P\[i\] = p\[i\]/K 연산을 수행한다.