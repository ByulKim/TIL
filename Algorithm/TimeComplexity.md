## 시간복잡도 : Time Complexity

---
- 알고리즘의 속도를 절차로 계산한 것 (완료되기까지 얼마나 많은 절차를 거쳐야 하는지)
- 입력된 데이터의 크기(N)에 따라 실행되는 **연산의 수를 계산**한다.
- 실행시간이 아닌 연산의 수로 판단하는 이유  
  → 실행시간은 컴퓨터의 성능, 사용된 언어, 컴파일러의 속도 등 영향을 주는 많은 요인들이 있기 때문이다.

### Big O notation (빅오 표기법)

---
- 시간복잡도를 설명하는 표기법 중 하나로, **최악의 경우를 판단하여 계산**한다.
- 최악의 경우로 판단하는 이유  
  → 알고리즘의 모든 경우의 수를 포함하기 위함이다.
- 규칙
    - 계수와 낮은 차수의 항은 무시한다 : O(2N2+N) → O(N2)
    - 상수는 무시한다 : O(N+2) → O(N), O(3N) → O(N)
- 종류
  - **Constant Time (상수 시간)**
      - O(1)
      - 입력에 관계없이 같은 절차를 거친다. (= 복잡도는 동일하게 유지된다.
      - 항상 같은 절차로 진행되어 이상적이다.
  - **Linear Time (선형 시간)**
      - O(N)
      - 입력된 데이터의 크기가 N 일때, N개의 절차를 거친다.
      - 데이터가 증가하면 절차도 선형적으로 증가한다.
  - **Quadratic Time (2차 시간)**
      - O(n2)
      - 주로 중첩 반복(nested loop) 이 있을 때의 시간복잡도를 의미한다.
      - 데이터가 증가할 수록 절차가 급격하게 상승한다.
  - **Logarithmic Time (로그 시간)**
      - O(log N)
      - 주로 정렬 알고리즘(이진 검색)시의 시간 복잡도를 의미한다.
          - 검색하는 데이터의 사이즈가 2배 증가해도 스텝은 1추가된다. (한번만 더 나누면 되니까)