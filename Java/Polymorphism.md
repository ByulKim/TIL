[김영한의 실전 자바 - 기본편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%8E%B8) 강의를 수강하며 공부한 내용 기록

# 다형성

다양한 형태의 성질을 가짐, 한 객체가 다른 타입의 객체로 취급될 수 있는 능력
- [다형적 참조](#다형적-참조)
- [캐스팅(형변환)](#캐스팅형변환)
- [instanceof](#instanceof)
- [메서드 오버라이딩](#메서드-오버라이딩)
- [다형성의 활용](#다형성의-활용)
- [추상 클래스 / 추상 메서드](#추상-클래스--추상-메서드)
- [인터페이스](#인터페이스)
- [좋은 객체 지향 프로그래밍이란](#좋은-객체-지향-프로그래밍이란)
- [OCP 원칙 (open-closed principle)](#ocp-원칙-open-closed-principle)

---   

---

### 다형적 참조

하나의 타입으로 다양한 인스턴스를 참조하는 것

---

- 부모 타입의 변수가 자식 인스턴스를 참조할 수 있다. (부모는 자식을 담을 수 있음)

    ```java
    Parent parent = new Child();
    ```

    - 자식 인스턴스를 생성하면 생성된 인스턴스 안에 부모의 인스턴스 영역도 존재하기 때문에 참조가 가능하다.
- 반대로 자식 타입의 변수가 부모 인스턴스를 참조할 수 없다. (자식은 부모를 담을 수 없음)
    - 부모 인스턴스를 생성하면 부모의 인스턴스만 존재하기 때문에 자식 인스턴스를 참조할 수 없다.


> ❓ 다른 타입의 변수를 대입하려면 기본적으로 형 변환이 필요한데, 다형적 참조에서는 어떻게 형변환을 진행할까 ?
   
### 캐스팅(형변환)

---

1. 업 캐스팅 : 부모 타입의 변수가 자식 타입의 인스턴스를 참조할 때 발생한다.

    ```java
    Parent parent = (Parent) new Child();
    ```

    - 위와 같이 Child 인스턴스를 생성하고 형변환을 진행하여 부모 타입의 변수에 대입한다.
    - 더 큰 범위로의 형변환은 생략이 가능하기에 위와 같은 경우는 생략을 권장한다.

1. 다운 캐스팅 : 자식 타입의 변수가 부모 타입의 인스턴스를 참조할 때 발생한다.

    ```java
    Child child = (Child) new Parent();
    ```

    - 위와 같이 Parent 인스턴스를 생성하고 형변환을 진행하여 자식 타입의 변수에 대입한다.
    - 하위의 인스턴스가 생성되지 않았는데 다운 캐스팅 할 경우 문제 발생할 수 있다.
      (부모의 인스턴스 생성시에 자식 인스턴스는 생성되지 않기에 child 변수를 통해 자식 인스턴스에 접근하려 하면 오류가 발생한다.)
    - 잘못된 경우 ClassCastException 오류가 발생한다. (런타임 오류)

> 참고   
> - 런타임 오류 : 프로그램을 실행하는 도중에 발생하는 오류이다.   
> - 컴파일 오류 : 프로그램을 실행하기 전에 발생하는 오류이다.   
> (오타, 잘못된 클래스 이름 사용 등 실행 전에 알 수 있어 좋은 오류!)
>

> ❓그럼 호출하기 전에 실제로 인스턴스가 존재하는지 확인하면 런타임 오류를 방지할 수 있지 않을까 ?

### instanceof

실제 변수가 참조하고 있는 인스턴스를 확인

---

- `{인스턴스 변수명} instanceof {클래스명}` 으로 선언

    ```java
    new Parent() instanceof Parent // true
    new Parent() instanceof Child; // false
    
    new Child() instanceof Parent; // true
    new Child() instanceof Child; // true
    ```

    - 맞으면 true
    - 아니면 false
- 왼쪽의 인스턴스 타입이 오른쪽의 클래스 타입에 들어갈 수 있는지 대입해 보면 알 수 있다.

- [Java16 부터 사용가능] Pattern Matching for instanceof
    - `{인스턴스 변수명} instanceof {클래스명} {다운 캐스팅 할 인스턴스 변수명}` 으로 사용하여 확인 및 바로 다운캐스팅이 가능하다.
    - 다운 캐스팅 코드 생략이 가능하여 편리하다.

### 메서드 오버라이딩

상위의 기능을 하위의 클래스가 새로운 기능으로 재정의 하는 것

---

- 하위 클래스의 인스턴스를 생성하면 상위의 인스턴스도 함께 생성되는데,
  생성된 인스턴스 안에서 오버라이딩 된 메서드는 항상 우선권을 가진다.

    ```java
    Parent parent = new Child();
    
    parent.value; // parent 의 value
    parent.method(); // Child 에서 오버라이딩한 메서드 호출됨
    ```

> ❓다형적으로 참조할 수 있다는 것도 알겠고, 메서드 오버라이딩 되면 우선권을 갖는것도 알겠는데
  이게 왜 필요하지? 더 복잡하기만 한 것 같은데…

### 다형성의 활용

---

- 같은 부모(상위)를 가진 여러 자식 클래스가 있다고 가정했을 때,
  이를 실행하는 부분에서 같은 기능을 수행하려면 중복 코드가 발생할 수 있다.

    ```java
    Pig pig = new Pig();
    pig.sound(); // 돼지의 울음소리. 꿀꿀.
    
    Dog dog = new Dog();
    dog.sound(); // 개의 울음소리. 멍멍.
    ```

    - 위와 같이 Animal 이라는 클래스를 상속받는 Pig, Dog 클래스가 있다고 가정할 때,
      이들의 울음소리를 출력하는 sound 라는 함수는 각 동물마다 중복해서 호출해야 하고,
      동물이 추가되면 코드가 계속해서 길어지게 된다.
    - 코드 작성시에 중복을 제거하고 싶어도, 타입이 다른 변수로 묶여있어
      메서드로 분리해 인자로 넘기거나 배열, for문에서 사용할 수 없다.
    - 타입이 다른 변수를 묶을 수 없기 때문에 결과적으로 최적화를 하기 어렵다.

- 그럼 만약 모두 같은 타입을 사용한다면?

    ```java
    Animal[] animals = {new Pig(), new Dog()};
    
    for (animal : Animals) {
    	animal.sound();
    }
    ```

    - **(다형성 참조 덕분에) 같은 상위 타입 변수에 각각의 인스턴스를 담을 수 있다.**
    - **(메서드 오버라이딩을 통해) 런타임 호출 시점에 하위 타입의 메서드를 호출할 수 있다.**

> ❓동물 클래스는 사실상 돼지/개 를 공통으로 표현하기 위한 개념이라 인스턴스 될 필요성이 없는 클래스네?

> ❓돼지/개 의 경우에는 각자의 울음소리를 내려면 sound 라는 함수를 반드시 재정의 하도록 해야하지 않나?

### 추상 클래스 / 추상 메서드

---

- 상위 클래스를 생성하는 문제
    - 추상적 개념의 클래스는 인스턴스를 생성해서 사용해야 할 일이 없을 수 있다.
    - 인스턴스를 생성하면 작동은 하지만 큰 의미가 없다.
- 하위 클래스에서 오버라이딩 하지 않을 문제
    - 무조건 오버라이딩 하도록 해야하는 경우가 있을 수 있다. (오버라이딩 하지 않으면 상위의 메서드가 호출되기 때문)

1. **추상 클래스**

    ```java
    public abstract class Animal {
    }
    ```

    - 추상적인 개념을 정의한 클래스
    - 인스턴스 생성이 불가능하다.
    - 상속을 목적으로 사용된다. (자식 클래스의 상위 개념을 위해)
    - 실제 인스턴스를 생성할 수 없다는 제약을 제외하고는 일반적인 클래스와 동일하다.
    - `class` 키워드 앞에 `abstract` 키워드를 붙여주면 된다.
2. **추상 메서드**

    ```java
    public abstract class Animal {
    		public abstract void sound();
    }
    ```

    - 자식 클래스에서 반드시 오버라이딩 해야하는 메서드
    - 실체가 존재하지 않고, 메서드 바디가 없다. (바디를 가질 수 없다.)
        - 오버라이딩 하지 않으면 부모의 메서드가 호출되어야 하는데, 바디가 없기에 호출될 수 없다.
    - 추상 메서드가 존재하려면 속한 클래스가 반드시 추상 클래스여야 한다.
    - 만약 자식 클래스가 오버라이딩 하지 않으려면 자식 클래스도 추상 클래스가 되어야 한다.
    - 추상 메서드를 통해 자식 클래스에서 오버라이딩을 누락하는 것을 방지한다.
    - 반환 타입 앞에 `abstract` 키워드를 붙여주면 된다.
3. 순수 추상 클래스

    ```java
    public abstract class Animal {
    		public abstract void sound();
    		public abstract void run();
    }
    ```

    - 모든 메서드가 추상 메서드인 추상 클래스
    - 자식 클래스는 모든 기능(메서드)을 오버라이딩 해야한다.
    - 이렇게 사용하는 경우, 상속의 의미를 잃는다.
        - 상속은 부모가 만들어둔 기능을 물려받아 사용하는 것이 목적인데 물려받을 기능이 존재하지 않는다.
        - 부모의 기능을 물려받는 목적 보단 다형성을 위한 타입으로 껍데기 역할만 제공한다.

### 인터페이스

하위 클래스에서 지켜야 할 제약(규격)을 정의

---

```java
public interface Animal {
		void sound();
}

public class Dog implements Animal {
		@Override
	  public void sound() {
        System.out.println("멍멍");
    }
}
```

- `class` 대신 `interface` 라는 키워드를 사용한다.
- 모든 메서드는 `public abstract` 이다. (생략가능, 생략이 권장됨)
    - 여러곳에서 사용하는 목적이기에 public 으로 한다.
- 모든 멤버변수는 `public static final` 이다.(생략가능, 생략이 권장됨)
    - 인터페이스는 인스턴스를 생성하여 사용하는 것이 아니기 때문에 상수만 정의할 수 있다.
- 인터페이스는 상속이 아닌 구현이라고 표현한다. (물려받는 것이 아니라 규약이기 때문)
- 다중구현을 지원한다.
    - 상속은 다이아몬드 문제가 발생하여 다중 상속이 불가능하다.
        - 다이아몬드 문제 : 여러 클래스를 상속 받게 되면 호출시에 어떤 메서드를 호출해야할지 모르는 상황 발생
    - 인터페이스는 모두 추상 메서드로 이루어져있어 하위에서 반드시 오버라이딩 하기 때문에 가능하다.
      (호출시에 하위의 메서드가 호출됨)
- 구현 클래스에서는 implements 키워드를 사용하며 다중 구현의 경우 , 로 구분한다.
- 클래스 상속, 인터페이스 구현 함께 사용하는 경우
    - 상속은 하나만, 인터페이스는 여러개 가능하기 때문에 함께 사용하는 경우에는 extends 를 먼저 정의한다.

> ❓추상 클래스로도 표현이 가능한데 왜 인터페이스를 사용할까?   
> - 클래스는 상속받아 사용해야 하기 때문에 인터페이스보다 규약의 의미가 덜 느껴진다.   
> - 추상 클래스의 경우에는 추상 메서드가 아닌 실행 가능한 메서드도 정의할 수 있기에 규약의 목적에 벗어날 수 있다.   
> - 인터페이스는 다중 구현이 가능하여, 여러 규약을 사용할 수 있다.

### 좋은 객체 지향 프로그래밍이란

현실에 있는 사물/개념 들을 역할과 구현으로 구분해보면 많은것을 표현할 수 있다.

---

[ 역할 : 인터페이스 ]

[ 구현 : 인터페이스를 구현한 클래스, 구현 객체 ]

- 어떤 기능을 사용하는 클라이언트(요청자)가 구현된 객체를 바라보고 있다고 했을 때
  객체가 변하거나, 새로 추가되는 경우 클라이언트도 수정이 필요하다.
- 구현된 객체를 바라보는 것이 아니라 그 상위 개념인 역할을 바라보고 있다면
  객체가 변하거나, 새로 추가되어도 클라이언트는 수정되지 않는다.

- 인터페이스(역할)를 바라보는 것
    - 다형성을 통해 인터페이스 타입의 변수를 선언하고, 그 변수를 통해 구현 객체에 접근한다.
    - 유연하고 변경이 용이하다.
    - 결과적으로 클라이언트(요청자)의 코드를 변경하지 않고 서버(응답자)의 구현 기능을 유연하게 변경할 수 있다.
    - (but) 인터페이스가 변경되면 전체적으로 큰 변경이 발생하기 때문에, 안정적으로 잘 설계하는 것이 중요하다.

### OCP 원칙 (open-closed principle)

---

- **open for extension** : 새로운 기능의 추가나 변경이 생겼을 때 기존 코드는 확장할 수 있어야 한다.
    - 새로운 구현 객체를 추가할 수 있다.
    - 새로 추가된 구현 객체를 클라이언트에서 호출할 수 있다.
- **closed for modification** : 기존 코드는 수정되지 않아야 한다.
    - 실행을 위한 코드가 아닌 프로그램의 핵심 코드(클라이언트)는 수정하지 않도록 해야 한다.
- 다형성을 사용하여 역할과 구현을 분리해두었기 때문에 이 원칙을 지킬 수 있다.
- 변하는 부분과, 변하지 않는 부분을 분리하여 개발하면 이 원칙을 지킬 수 있다.