# java.lang

## java.lang 패키지란?

---

- import 없이 사용 가능한 패키지이다.
- 여러 클래스에서 공통적으로 사용할 수 있는 많은 기능들을 가지고 있다.
- 분류
    - `Object`: 모든 자바 객체의 부모 클래스
    - `String`: 문자열 클래스
    - `Integer`,`Long`,`Double`: 래퍼클래스, 래퍼 타입 (기본형 데이터 타입을 객체로 만든 것)
    - `Class`: 클래스의 메타정보를 제공하는 클래스
    - `System`: 시스템과 관련된 기본 기능을 제공하는 클래스
    - 어노테이션
        - `Override`, ...
    - 쓰레드, 예외, 런타임 관련
        - `Thread`
        - `Throwable`, `Exception`
        - OutOfMemoryError
            - 메모리가 부족하여 발생하는 오류
        - StackOverflowError
            - 스택에 쌓을 수 있는 메서드 호출 정보의 한계를 넘었을 때 발생하는 오류

## Object 클래스

---

- 모든 클래스의 최상위 부모 클래스
    - 부모가 없으면 묵시적으로 Object 클래스를 상속 받는다 (묵시적 상속)
    - 자식의 인스턴스 생성 시에 Object 인스턴스도 함께 생성된다.
- `extends Object`가 생략되어 있는 것이다.
- 장점
    - 공통 기능을 제공하므로써 코드의 단순화, 일관성이 유지된다.
        - 관계가 없는 객체들이 같은 기능을 사용하고 싶을 때, Object 클래스가 없다면 각각 다 생성해 주어야 한다.
        - ex) 객체와 다른 객체 비교, 객체의 정보 확인
    - 다형성의 기본 구현
        - 모든 자바 객체는 Object 타입으로 처리될 수 있다.
        - \= 다양한 타입의 객체를 통합적으로 처리할 수 있다.
- 단점, 한계
    - 실제 객체를 호출하려면 다운캐스팅 과정이 필요하다.
    - 다형성(메서드 오버라이딩) 의 한계가 있다.
        - Object 타입으로 다형적 참조는 가능하지만, 실제 각 객체가 지닌 특성을 모르기 때문에 사용에 한계가 있다.
- 언제 활용하면 좋은가
    - Object 배열`Object[]`
        - 모든 객체를 담을 수 있는 배열
    - 공통 메서드 사용 (오버라이딩)
        - `toString()`
        - `equals()`

> 1. 정적 의존관계
>    - 클래스 간의 의존관계
>    - 컴파일 시에 결정된다.
>    - 일반적으로 이야기하는 의존관계를 의미한다.
>    - 클래스 내에서 사용하는 타입들을 보면 쉽게 파악이 가능하다.
> 2. 동적 의존관계
>    - 런타임 시에 확인 가능하다.
>    - 상위 타입으로 정의된 부분에 실제 어떤 객체가 전달 될지는 실행시에 알 수 있다.

### toString() : 객체에 대한 정보를 반환

---

- 객체의 정보를 문자열 형태로 전달한다.
- `패키지명.클래스명@객체의 참조값(해시코드)`16진수로 표현한다.
- `System.out.println()`메서드는 내부에서`toString()`을 호출한다.
- 오버라이딩
    - IDE 의 도움을 받아 자동 생성하면 멤버변수들을 포함한 정보 출력 메서드를 만들 수 있다.
- 객체의 참조값을 직접 확인하고 싶은 경우
    - `Integer.toHexString(System.identityHashCode(참조값));`
- OCP
    - open for extension
        - 새로운 클래스(개념)의 확장이 가능하다.
        - `Object.toString()`> 하위 클래스를 추가하거나 재정의가 가능하다.
    - closed for modification
        - 수정하더라도 사용하는 클라이언트 코드는 변경하지 않아도 된다.
        - `System.out.println()`> 클래스가 추가 되더라도`toString()`을 호출하는 이 부분은 변하지 않는다.

### equals()

---

- 동일성(identity)
    - `==`
    - 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
    - 완전히 같음을 의미 = 물리적
- 동등성(Equality)
    - `equals()`
    - 두 객체가 논리적으로 동등한지 확인 = 논리적

```java
User a = new User("ID-100");
User b = new User("ID-100");

a ==b; // false
a.equals(b); // false
```

- Object 가 기본으로 제공하는`equals()`는`==`으로 객체를 비교한다.
    - 동등성(논리적으로 같음) 비교를 하고 싶다면 오버라이딩을 통해 처리해야 한다.

```java
public class User {
    private String id;

    @Override
    public boolean equals(Object obj) {
        User user = (User) obj;
        return id.equals(user.id);
    }
}
```

- 정확하게`equals()`메서드를 오버라이딩 하려면, 몇가지 규칙을 지켜야 한다.
    - IDE에서 제공해주는 기능을 사용하면 쉽게 만들 수 있다.

## Immutable Object (불변객체)

---

- 객체의 상태(객체 내부의 값, 멤버 변수)가 변하지 않는 객체
- 왜 필요한가 ?
    - 객체는 참조형 타입으로, 여러 변수에서 하나의 객체를 공유할 수 있다.
    - 객체를 공유 참조하면 인스턴스가 하나이니 메모리가 절약되고, 생성시간도 줄어 성능상 효율적이다.
    - 하지만 한쪽의 변경이 다른쪽에 영향을 미쳐 사이드 이펙트가 발생할 수 있다.
    - 이럴때, 공유된 객체의 값을 바꾸지 못하게 설정한다면 이 문제를 해결할 수 있다.
  > 기본형 타입 : 하나의 값을 여러 변수에서 공유하지 않는다. (복사하여 대입)   
  참조형 타입 : 하나의 객체를 참조값을 통해 여러 변수에서 공유할 수 있다.
- 불변객체 설정
    - `final`키워드를 사용하여 멤버 변수를 생성한다.
    - `set`메서드를 제거한다.
- 불변객체의 값 변경
    - 값 자체를 변경하면 안되기 때문에, 변경된 값을 가지는 객체를 반환하는 메서드를 생성하여 처리한다.
    - 메서드명에`with`를 사용하는 경우가 많음
        - `withYear()` : year 를 변경한 새로운 객체를 반환한다는 의미 (원본은 유지됨)

## String (문자열 클래스)

---

- 자바에서 문자를 다루는 타입은`char`,`String`이 있다.
    - `char`
        - 하나의 문자를 담을 수 있음
        - 여러개의 문자를 담으려면 배열로 생성해야 한다.`char[]`
- `String`은 참조형 타입
- 문자열은 매우 자주 사용되기 때문에 자바에서 자동으로 객체를 생성한다.

```java
String str = "hello"; // String str = new String("hello");
```

- String 클래스는 char 배열 / byte 배열을 멤버 변수로 가지고 있다.
    ```java
    public class String {
        private final char[] value; // 자바 9 이전
        private final byte[] value; // 자바 9 이전
    }
    ```
    - 문자열 자체는 각 문자로 쪼개져서 배열로 저장된다.
    - byte 로 변경된 이유
        - 영어, 숫자의 경우1byte를 차지하고, 나머지의 경우 2byte를 차지하는데   
          char 타입의 경우 2byte를, byte타입의 경우 1byte를 사용하기에 메모리 효율을 위해 변경되었다.
- 기능
    - `length()`: 문자열의 길이를 반환한다.
    - `isEmpty()`: 문자열이 비어있는지 확인한다.
    - `charAt(int index)`: 특정 인덱스 위치의 문자를 반환한다.
    - `substring(int beginIndex, int endIndex)`: 해당 범위의 문자열을 반환한다.
    - `indexOf(String str)`: 해당 문자열 부분이 시작되는 인덱스를 반환한다.
    - 변경 메서드의 경우 반환값을 받아 처리해야 한다. (문자열이 변경되는것이 아니라 새로운 문자열을 생성해 반환함)
        - `toLowerCase()`,`toUpperCase()`: 문자열을 소문자/대문자로 변환한다.
        - `trim()`,`strip()`: 문자열 양 끝의 공백을 제거한다.
        - `concat(String str)`: 해당 문자열을 더한다.
            - 문자열을 더할 때는 concat()과 같은 메서드를 사용해야 한다.
            - 하지만 편의를 위해 자바에서 특별히`+`연산을 사용할 수 있도록 제공한다.
        - `split(String regex)`: 특정 문자열로 쪼개서 문자열 배열을 반환한다.
        - static 메서드
            - `join(CharSequence delimiter, CharSequence... elements)`: 특정 문자로 여러 문자열을 합친다.
                - `CharSequence`는`String`,`StringBuilder`의 상위 타입이다.
            - `valueOf()`: 전달된 인자를 문자열로 변경한다.
                - 기본형 타입을 매개변수로 하는 것과 객체 타입을 매개변수로 하는 것 오버로딩 되어 있음
- 비교
    ```java
    String str1 = new String("hello");
    String str2 = new String("hello");
    
    str1 == str2; // false
    str1.equals(str2); // true
    ```
    - 비교 시에는 항상`equals()`메서드를 사용해야 한다.
    - String 클래스에서 오버라이딩 되어 있다.
    - 값이 같은지 비교하여 반환한다.

    ```java
    String str1 = "hello";
    String str2 = "hello";
    
    str1 == str2; // true
    str1.equals(str2); // true
    ```
    - 문자열 리터럴을 사용시에는 왜 `==` 연산에서도 true 가 될까?
    - **문자열 리터럴 , 문자열 풀**
        - 자바 실행 시점에 문자열 리터럴이 있으면 문자열 풀에 String 인스턴스를 미리 만들어 둔다.
        - 같은 문자열이 있다면 만들지 않고 함께 공유한다.
        - 따라서 실제로 같은 인스턴스를 참조하기에 `==` 연산이 true가 된다.
        - 문자열 풀 덕분에 같은 문자를 사용하는 경우,  
          메모리 사용을 줄이고 문자를 만드는 시간도 줄어들어 성능도 최적화 할 수 있다.
        - 문자열 풀은 힙 영역을 사용한다.
        - 해시 알고리즘을 사용하여 빠르게 찾을 수 있다.
    - 항상`equals()`를 사용해야 하는 이유
        - 리터럴을 사용하는 경우에는 `==` 으로 해도 되지 않나?
        - 어떻게 `String` 객체를 생성할지가 정해져있지 않기 때문에, 항상 실제 값을 비교하는`equals()`메서드를 사용해야한다.
    - `String` = 불변 객체
        - `String` 은 불변 객체로 내부의 값을 절대로 변경할 수 없다.
        - 변경이 필요한 경우, 새로운 객체를 생성해 반환한다.
        - `concat()` 의 경우, 새로운 문자열을 합친 후 새로운 `String` 객체를 반환한다.
        - 만약 값을 변경할 수 있다면, 문자열 풀에서 해당 인스턴스를 함께 참조하는 값들이 함께 영향을 받게 된다.
            - 불변 객체로 설정하여 값이 변해 발생하는 문제를 방지한다.

### StringBuilder - 가변 String

---

- 불변인 `String`의 단점은, 문자를 더하거나 변경할 때 계속해서 새로운 객체를 생성해야 한다는 점이다.
    - 변경하는 과정에 있는 객체도 생성된다. (사용하지 않게 됨)
    - 문자를 자주 변경할수록, 문자열의 크기가 클수록 cpu, 메모리 자원을 더 많이 사용하게 됨
- 사이드 이펙트에 주의하여 사용해야 한다.
- 기능
    - `append(String str)`: 뒤로 문자열을 이어 붙인다.
    - `insert(int offset, String str)`: 해당 인덱스 위치에 문자열을 추가한다.
    - `toString()`: String 객체로 반환한다.
- 변경을 진행하다가 `String` 객체로 변환 하고 사용하는 것이 좋다.
- `StringBuffer`
    - `StringBuilder`와 같이 가변 `String` 객체이다.
    - 동기화 처리가 되어 있어, 스레드에 안전하다.
    - 동기화 오버헤드로 인해 성능이 느리다.
    - 문자열을 멀티 쓰레드에서 공유 자원으로 사용하는 경우에 고려해 볼 수 있다.

### String 최적화

---

- 자바가 변경에 대해 자동으로 최적화를 해주기 때문에 간단한 경우에는 `StringBuilder`와 같은 가변 클래스를 사용하지 않아도 된다.
    - 문자열 `+` 를 사용하면, 내부적으로 최적화를 수행하며 더해준다.
- 최적화가 어려운 경우 -`StringBuilder`를 사용하면 좋다.
    - 문자열을 루프 안에서 더하는 경우
        - 반복문의 경우에는 반복 횟수만큼 객체를 생성한다.
        - 컴파일 시점에 각 반복에서 문자열이 어떻게 변경될지 예측할 수 없기 때문이다.
    - 조건문을 통해 동적으로 문자열을 조작하는 경우
    - 복잡한 문자열의 특정 부분을 변경해야 하는 경우
    - 매우 긴 문자열을 변경해야 하는 경우

### Method Chaining (메서드 체이닝)

---

```java
public class ChainingClass {
    int value;

    public ValueAdder add(int addValue) {
        value += addValue;
        return this;
    }
}
```

- 자기 자신의 참조값을 반환하는 메서드를 통해 또 다른 메서드를 호촐할 수 있다.

```java
ChainingClass chainig = new ChaingClass();
chaing.add(1).add(2).add(3);
```

- 코드를 간결하고 읽기 쉽게 만들어준다.

```java
StringBuilder str = new StringBuilder();
str.append("hello").insert(1,"bb").reverse().toString();
```

- `StringBuilder`의 메서드들은 메서드 체이닝으로 사용할 수 있다.


- 자바의 라이브러리나 오픈 소스들은 메서드 체이닝 방식을 종종 사용한다.
    - 사용하기에 아주 편리하다.

## 래퍼클래스

---

- 기본형 변수인 int, double, boolean 과 같은 변수를 객체형으로 포장한 것이다.
    - int -> Integer, double -> Double, boolean -> Boolean
- 필요시 기본 자료형 처럼 사용할 수 있고, 객체를 생성하지 않아도 값을 할당할 수 있다.
- 참조형 변수의 경우 null 로 지정이 가능하기에, 아직 할당되지 않은 값이나 없는 값을 표현할 수 있다.
- 연관된 메서드를 함께 가지고 있어, 필요시에 사용할 수 있다.
- 숫자 클래스의 경우 MIN_VALUE, MAX_VALUE 와 같은 범위내 최소/최대값을 상수로 가지고 있어 필요시에 사용할 수 있다.
- 객체 타입을 매개변수로 받는 많은 메서드들을 사용할 수 있다.

## System 클래스

---

- 많이 사용하는 `System.out.println();` 출력 부분은 System 클래스를 이용한 것이다.
    - PrintStream 이라는 클래스의 메서드이다.
    - println() 은 매개변수가 없는 메서드가 존재하여 줄바꿈만을 실행할 시 호출할 수 있다.
        - 객체를 출력할 때 toString()으로 출력한다면 참조 변수의 값이 null인 경우 오류가 발생한다.   
          → valueOf() 메서드를 사용해 값을 출력하기 때문에 null인 경우에도 출력이 가능하다.
- 기능
    - GC 수행
        - 메모리는 자바가 알아서 관리하기 때문에 직접 처리하는 메서드를 사용하면 안된다.
    - JVM 종료
        - JVM을 강제로 종료시키면 시스템에 큰 장애가 발생할 수 있기 때문에 사용하면 안된다.
    - 현재 시간 관리
    - 시스템 속성값 관리
    - 환경값 조회
        - 시스템 속성 값은 추가 및 변경이 가능하지만, 환경값은 조회만 가능하다.
