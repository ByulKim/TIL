## HTTP

* * *

- 하이퍼 텍스트 전송 프로토콜


- 무상태성 (stateless)
    - 상태 유지가 되는경우, 서버를 변경할 수 없다는 단점이 있다.
        - 서버에 장애가 발생하거나 요청이 많아지는 경우 시스템 장애로 이어질 수 있다.
    - 유연한 서버 증설이 가능하다.
    - 로그인과 같은 기능을 위해서는 쿠키/세션 등을 이용해 상태를 유지하기도 한다.
        - 상태 유지는 최소한으로 진행해야 한다.
    - 클라이언트에서 전달하는 데이터양이 많아질 수 있다.


- 비연결성 (connectionless)
    - 요청-응답이 끝나면 연결을 종료한다.
    - 서버의 자원을 효율적으로 사용할 수 있다.
    - tcp 프로토콜을 통해 소켓을 연결해두고 데이터를 전송-응답 받은 후에 연결을 종료한다.
        - 소켓
            - 클라이언트-서버 네트워크의 각 끝 부분을 의미한다.
            - 데이터 전송을 위해 소켓을 열고 전송이 끝나면 소켓을 닫는다.
            - 소켓을 여는 것은 tcp 의 3-way handshaking 을 통해 진행된다.
    - 한계
        - 요청시마다 tcp 3-way handshaking 을 시도해야 한다.
        - 많은 자원을 받아야 할 때 계속해서 연결-끊기를 시도해야 한다.

    - (이제는) HTTP/1.1 부터는 Connection: keep-alive 헤더를 사용하여 연결을 유지한다.
        - 지속연결 (persistent connections) 을 사용한다.
        - HTTP/2,3 에서는 최적화를 통해 더 빠른 연결을 처리할 수 있다.

### URI

* * *

- Uniform Resource Identifier


- 리소스를 식별한다.


- URL(Locator)
    - 위치
    - URI = URL 로 보통 사용된다.
    - \[스키마-http\]://\[도메인명/ip\]\[:port\]\[/경로\]\[?쿼리파라미터/쿼리스트링\]


- URN(Name)
    - 이름
    - 이름만으로 리소스를 찾을 수 있는 방법이 보편화 되어 있지 않다.


- URI(URL) 입력 후 웹브라우저에서 페이지를 띄우는 흐름
    - http 프로토콜에 의해 도메인 명과 포트번호, 데이터 등을 파악한다.
    - 소켓 라이브러리를 거쳐 TCP로 전송된다.
    - 패킷을 받은 서버가 데이터를 확인하고 응답을 작성한다.
    - 같은 흐름으로 데이터를 가공하여 전송하고, 클라이언트가 받는다.
    - 웹브라우저가 응답으로 받은 html 코드를 화면으로 출력한다.


- DNS
    - Domain Name System
    - ip의 단점
        - 외우기 어렵다.
        - 변경될 수 있다.
    - 전화번호부처럼 이름과 ip 를 연결해두고 찾아간다.
    - 변경되었을 시에 이름은 변하지 않고 ip만 변경하면 된다.

### HTTP 메시지

* * *

- 구조
    - start-line 시작 라인
        - 요청 메시지 : request-line
            - http method
            - request-target
                - 절대경로 + 쿼리스트링
            - http version
        - 응답 메시지 : status-line
            - http version
            - status-code
            - reason-phrase (이유 문구)
    - header 헤더
        - http 전송에 필요한 모든 부가정보를 포함한다.
        - general 헤더
            - 메시지 전체에 적용되는 정보
        - request 헤더
            - 요청 정보
        - response 헤더
            - 응답 정보
        - entity 헤더
            - 엔티티 바디와 관련된 정보
            - 최신 스펙에서는 entity 라는 단어 사라지고 representation(표현) 이라고 부르게 되었다.
            - 표현 헤더, 표현 데이터
    - empty-line 공백 라인 (CRLF)
        - 반드시 포함해야 한다.
    - body 메시지 바디
        - 실제 전송할 데이터


- HTTP 메서드
    - 리소스
        - 회원 조회/수정/삭제 에서 ‘회원'이 리소스이다.
        - 회원을 가지고 URI를 설계해야한다.
        - 리소스를 대상으로하는 행위는 분리한다.
    - GET
        - 리소스 조회 시에 주로 사용한다.
        - 메시지 바디를 사용할 수 있지만, 지원하지 않는 서버가 있어 주로 쿼리 스트링을 통해 데이터를 전달한다.
        - 캐싱을 통해 데이터를 저장해두기 때문에 조회시에 유리하다.
        - 데이터를 변경하는 작업에서 GET 메서드를 사용하면 안되는 이유
            - 멱등성 : 항상 결과가 같아야 한다.
            - 캐싱 : 응답을 캐싱하는데, 수정 요청에 대한 응답은 캐싱되면 안된다.
            - 보안 : 데이터를 변경하는 것은 보통 사용자의 권한이나 인증을 필요로 하는데, 주소줄을 통해 요청하는 경우 데이터가 노출되어 있어 보안상 위험할 수 있다.- POST
        - 리소스 처리 시에 주로 사용한다.
        - 새로운 리소스 생성
            - 서버에서 만들고, 생성된 리소스 정보를 응답한다.
        - 데이터 처리
        - 조금 애매하면 POST로 (메시지 바디가 필요한 GET 요청이나)
    - PUT
        - 리소스를 완전히 대체 (없으면 생성)
        - 일부를 수정하는 것이 아니기에 모든 정보를 포함해야 한다.
        - 클라이언트가 리소스를 알고 있어 요청시에 지정된 리소스 정보를 전달한다.
            - 파일을 생성하는 경우, 중복된 파일이 없게 하려면 생성시에도 PUT 메서드를 사용해 요청한다.
    - PATCH
        - 리소스를 부분적으로 수정한다.
        - PATCH가 지원이 되지 않는 서버라면 POST를 사용하면 된다.
    - DELETE
        - 리소스를 삭제한다.
    - 특성
        - 안전 (Safe)
            - 리소스의 변경이 일어나지 않는 GET과 같은 메서드는 안전하다고 할 수 있다.
        - 멱등 (Idempotent)
            - 한번 호출하던, 여러번 호출하던 결과가 항상 동일하다.
            - GET, PUT, DELETE
            - 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.
        - 캐시가능 (Cacheable)
            - 응답 결과 리소스를 캐시로 사용하는 것을 말한다.
            - GET, HEAD 정도면 캐시로 사용한다.

### 프록시서버

* * *

- HTTP 클라이언트와 HTTP 서버 사이에 존재한다.
- 클라이언트는 프록시 서버로 요청을 보내고, 프록시 서버에서 목적지 서버로 전송한다.
    - 클라이언트가 8080 포트로 요청을 보내면, 프록시 서버는 80포트로 변환하여 서버로 전송한다.
- 클라이언트에서 어떤 웹서버로 접속하는지를 확인(감시)하거나, 접속을 제한하는 목적으로 사용될 수 있다. (웹 필터링, URL 필터링)
